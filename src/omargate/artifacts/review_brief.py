from __future__ import annotations

import time
from pathlib import Path
from typing import Dict, Iterable, List, Optional

from .priority_ranker import CATEGORY_SCORE, CATEGORIES, SEVERITY_SCORE, detect_categories, rank_files
from ..fix_plan import ensure_fix_plan
from ..ingest.codebase_snapshot import build_codebase_snapshot, build_codebase_synopsis

CATEGORY_ACTIONS = {
    "auth": "Review auth and session controls",
    "payment": "Verify payment flows and signature checks",
    "webhook": "Ensure webhook verification is enforced",
    "database": "Check query parameterization and access controls",
    "crypto": "Validate key handling and cryptography usage",
    "infrastructure": "Review CI/CD and infrastructure configs",
}

_SEVERITY_ORDER = {"P0": 0, "P1": 1, "P2": 2, "P3": 3}


def generate_review_brief(
    run_dir: Path,
    run_id: str,
    findings: List[dict],
    ingest: dict,
    scan_mode: str,
    version: str,
    dashboard_url: Optional[str] = None,
) -> Path:
    """Generate REVIEW_BRIEF.md in the run directory."""
    run_dir.mkdir(parents=True, exist_ok=True)
    content = render_review_brief(
        run_id=run_id,
        findings=findings,
        ingest=ingest,
        scan_mode=scan_mode,
        version=version,
        dashboard_url=dashboard_url,
    )
    out_path = run_dir / "REVIEW_BRIEF.md"
    out_path.write_text(content, encoding="utf-8")
    return out_path


def render_review_brief(
    run_id: str,
    findings: List[dict],
    ingest: dict,
    scan_mode: str,
    version: str,
    dashboard_url: Optional[str] = None,
) -> str:
    """Render review brief markdown without writing to disk."""
    timestamp = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    files_scanned = _files_scanned(ingest)
    counts = _count_by_severity(findings)
    detected_categories = _collect_detected_categories(findings, ingest)
    badges = _format_category_badges(detected_categories)

    snapshot_lines = _format_codebase_snapshot(ingest)

    ranked_files = rank_files(findings, ingest, top_n=10)
    risk_table = _format_risk_table(ranked_files)
    fix_plan_lines = _format_fix_plan_section(findings)
    review_order = _format_review_order(findings, ingest, ranked_files)
    quick_commands = _format_quick_commands(detected_categories)

    resolved_dashboard_url = dashboard_url or f"https://sentinelayer.com/runs/{run_id}"

    lines: List[str] = []
    lines.append("# ğŸ›¡ï¸ Omar Gate Review Brief")
    lines.append("")
    lines.append(f"**Run:** {run_id}  ")
    lines.append(f"**Scan:** {scan_mode} â€¢ {files_scanned} files â€¢ {timestamp}")
    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append("## Summary")
    lines.append("")
    lines.extend(_format_summary_table(counts))
    lines.append("")
    lines.append("---")
    lines.append("")

    if snapshot_lines:
        lines.append("## Codebase Snapshot (Deterministic)")
        lines.append("")
        lines.extend(snapshot_lines)
        lines.append("")
        lines.append("---")
        lines.append("")

    lines.append("## Categories Detected")
    lines.append("")
    lines.append(badges)
    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append("## Risk Hotspots")
    lines.append("")
    lines.append(
        "Files requiring immediate attention, ranked by severity + category + complexity:"
    )
    lines.append("")
    lines.extend(risk_table)
    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append("## Findings and Fix Plans")
    lines.append("")
    lines.extend(fix_plan_lines)
    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append("## Suggested Review Order")
    lines.append("")
    lines.append("Based on detected categories and finding density:")
    lines.append("")
    lines.extend(review_order)
    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append("## Quick Commands")
    lines.append("")
    lines.append("Find related code patterns:")
    lines.append("```bash")
    lines.extend(quick_commands)
    lines.append("```")
    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append("## Next Steps")
    lines.append("")
    lines.append("1. Review P0/P1 findings immediately")
    lines.append("2. Check Risk Hotspots in priority order")
    lines.append("3. Run suggested commands to find related issues")
    lines.append(
        "4. Request [HITL Review](https://sentinelayer.com/hitl) for expert validation"
    )
    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append(
        f"<sub>Generated by Omar Gate v{version} â€¢ [View Dashboard]({resolved_dashboard_url})</sub>"
    )
    lines.append("")

    return "\n".join(lines)


def _format_fix_plan_section(findings: List[dict]) -> List[str]:
    if not findings:
        return ["No findings."]

    sorted_findings = sorted(
        (f for f in findings if isinstance(f, dict)),
        key=lambda f: (
            _SEVERITY_ORDER.get(str(f.get("severity", "")).upper(), 99),
            str(f.get("file_path") or ""),
            int(f.get("line_start") or 0),
        ),
    )

    lines: List[str] = []
    for idx, finding in enumerate(sorted_findings, start=1):
        severity = str(finding.get("severity") or "P3").upper()
        category = str(finding.get("category") or "issue")
        path = str(finding.get("file_path") or "unknown").replace("\\", "/")
        line = int(finding.get("line_start") or 1)
        message = _truncate_message(str(finding.get("message") or "No description"), 220)
        fix_plan = ensure_fix_plan(
            fix_plan=finding.get("fix_plan", ""),
            recommendation=finding.get("recommendation", ""),
            message=finding.get("message", ""),
        )
        lines.append(
            f"{idx}. **{severity}** `{path}:{line}` Â· **{category}**: {message}"
        )
        lines.append(f"   > **Fix:** {fix_plan}")
        lines.append("   > **Apply Fix:** Coming soon.")

    return lines


def _truncate_message(text: str, max_chars: int = 220) -> str:
    normalized = " ".join(str(text or "").strip().split())
    if len(normalized) <= max_chars:
        return normalized
    if max_chars <= 3:
        return normalized[:max_chars]
    return f"{normalized[: max_chars - 3]}..."


def _format_codebase_snapshot(ingest: dict) -> List[str]:
    """Return a small, deterministic codebase summary for the review brief."""
    try:
        snapshot = build_codebase_snapshot(ingest)
    except Exception:
        return []

    stats = snapshot.get("stats", {}) if isinstance(snapshot, dict) else {}
    deps = snapshot.get("dependencies", {}) if isinstance(snapshot, dict) else {}
    languages = snapshot.get("languages", []) if isinstance(snapshot, dict) else []
    god_files = snapshot.get("god_files", []) if isinstance(snapshot, dict) else []

    in_scope = int(stats.get("in_scope_files", 0) or 0)
    loc = int(stats.get("source_loc_total", 0) or 0)
    pm = str(deps.get("package_manager") or "unknown")

    lines: List[str] = []
    lines.append(f"- In-scope files (source): `{in_scope}`")
    lines.append(f"- LOC (source only): `{loc:,}`")
    lines.append(f"- Package manager: `{pm}`")
    synopsis = build_codebase_synopsis(codebase_snapshot=snapshot)
    if synopsis:
        lines.append(f"- Synopsis: {synopsis}")

    if languages:
        top = []
        for item in languages[:5]:
            lang = str(item.get("language") or "unknown")
            loc_lang = int(item.get("loc", 0) or 0)
            top.append(f"`{lang}` ({loc_lang:,} LOC)")
        lines.append(f"- Top languages: {', '.join(top)}")

    if god_files:
        threshold = int(snapshot.get("god_threshold_loc", 1000) or 1000)
        top = []
        for item in god_files[:5]:
            path = str(item.get("path") or "?")
            loc_item = int(item.get("lines", 0) or 0)
            top.append(f"`{path}` ({loc_item:,} LOC)")
        lines.append(f"- God components (>= {threshold} LOC): {', '.join(top)}")

    lines.append("- Artifacts: `CODEBASE_INGEST_SUMMARY.md` / `CODEBASE_INGEST_SUMMARY.json`")

    return lines


def _files_scanned(ingest: dict) -> int:
    stats = ingest.get("stats", {}) if isinstance(ingest, dict) else {}
    in_scope = stats.get("in_scope_files")
    if in_scope is not None:
        return int(in_scope)
    total = stats.get("total_files")
    if total is not None:
        return int(total)
    files = ingest.get("files", []) if isinstance(ingest, dict) else []
    return len(files)


def _count_by_severity(findings: Iterable[dict]) -> Dict[str, int]:
    counts = {"P0": 0, "P1": 0, "P2": 0, "P3": 0}
    for finding in findings:
        sev = str(finding.get("severity", "")).upper()
        if sev in counts:
            counts[sev] += 1
    return counts


def _format_summary_table(counts: Dict[str, int]) -> List[str]:
    return [
        "| Severity | Count |",
        "|----------|-------|",
        f"| ğŸ”´ P0 (Critical) | {counts.get('P0', 0)} |",
        f"| ğŸŸ  P1 (High) | {counts.get('P1', 0)} |",
        f"| ğŸŸ¡ P2 (Medium) | {counts.get('P2', 0)} |",
        f"| âšª P3 (Low) | {counts.get('P3', 0)} |",
    ]


def _collect_detected_categories(findings: List[dict], ingest: dict) -> List[str]:
    hotspots = ingest.get("hotspots", {}) if isinstance(ingest, dict) else {}
    detected: List[str] = []

    for finding in findings:
        path = finding.get("file_path")
        if not path:
            continue
        for category in detect_categories(str(path), hotspots):
            if category not in detected:
                detected.append(category)

    for category, files in hotspots.items() if isinstance(hotspots, dict) else []:
        if files and category not in detected and category in CATEGORIES:
            detected.append(category)

    return detected


def _format_category_badges(categories: List[str]) -> str:
    if not categories:
        return "None detected"
    parts: List[str] = []
    for key in _category_order(categories):
        config = CATEGORIES.get(key)
        if not config:
            continue
        parts.append(f"`{config['icon']} {config['name']}`")
    return " ".join(parts)


def _format_risk_table(ranked_files: List[dict]) -> List[str]:
    lines = [
        "| Priority | File | Category | Issues | Action |",
        "|----------|------|----------|--------|--------|",
    ]

    if not ranked_files:
        lines.append("| - | - | - | - | - |")
        return lines

    for idx, item in enumerate(ranked_files, start=1):
        path = item.get("path", "?")
        categories = item.get("categories") or []
        primary = _primary_category(categories)
        category_label = _category_label(primary)
        issue_summary = _issue_summary(item.get("findings") or [])
        action = CATEGORY_ACTIONS.get(primary, "Review high-risk changes")
        lines.append(
            f"| {idx} | `{path}` | {category_label} | {issue_summary} | {action} |"
        )

    return lines


def _format_review_order(
    findings: List[dict],
    ingest: dict,
    ranked_files: List[dict],
) -> List[str]:
    if not findings and not (ingest.get("hotspots") if isinstance(ingest, dict) else None):
        return ["No category signals detected."]

    hotspots = ingest.get("hotspots", {}) if isinstance(ingest, dict) else {}
    category_files: Dict[str, List[str]] = {key: [] for key in CATEGORIES}
    category_findings: Dict[str, List[dict]] = {key: [] for key in CATEGORIES}

    for finding in findings:
        path = finding.get("file_path")
        if not path:
            continue
        for category in detect_categories(str(path), hotspots):
            if str(path) not in category_files[category]:
                category_files[category].append(str(path))
            category_findings[category].append(finding)

    for category, files in hotspots.items() if isinstance(hotspots, dict) else []:
        if category not in category_files:
            continue
        for path in files:
            if str(path) not in category_files[category]:
                category_files[category].append(str(path))

    ranked_paths = [item.get("path") for item in ranked_files if item.get("path")]

    order = sorted(
        CATEGORIES.keys(),
        key=lambda key: (
            -_severity_sum(category_findings.get(key, [])),
            -len(category_files.get(key, [])),
            -CATEGORY_SCORE.get(key, 1),
        ),
    )

    lines: List[str] = []
    index = 1
    for category in order:
        files = category_files.get(category, [])
        findings_count = len(category_findings.get(category, []))
        if not files and findings_count == 0:
            continue

        ordered_files = _order_files(files, ranked_paths)
        files_display = ", ".join(f"`{path}`" for path in ordered_files[:5])
        if not files_display:
            files_display = "(no files detected)"

        lines.append(
            f"{index}. **{_category_label(category)}** â€” {len(files)} files, {findings_count} findings â€” {files_display}"
        )
        index += 1

    if not lines:
        return ["No category signals detected."]

    return lines


def _format_quick_commands(categories: List[str]) -> List[str]:
    if not categories:
        return ["# No category-specific commands available"]

    lines: List[str] = []
    for key in _category_order(categories):
        config = CATEGORIES.get(key)
        if not config:
            continue
        lines.append(f"# {config['name']} patterns")
        for command in config.get("commands", []):
            lines.append(str(command))
        lines.append("")

    if lines and lines[-1] == "":
        lines.pop()
    return lines


def _category_order(categories: List[str]) -> List[str]:
    return [key for key in CATEGORIES.keys() if key in categories]


def _category_label(category: Optional[str]) -> str:
    if not category:
        return "Uncategorized"
    config = CATEGORIES.get(category)
    if not config:
        return category
    return f"{config['icon']} {config['name']}"


def _primary_category(categories: List[str]) -> Optional[str]:
    if not categories:
        return None
    return max(categories, key=lambda key: CATEGORY_SCORE.get(key, 1))


def _issue_summary(findings: List[dict]) -> str:
    if not findings:
        return "0"
    counts = _count_by_severity(findings)
    parts = [
        f"{counts[severity]} {severity}"
        for severity in ("P0", "P1", "P2", "P3")
        if counts.get(severity)
    ]
    return " â€¢ ".join(parts) if parts else "0"


def _severity_sum(findings: List[dict]) -> int:
    return sum(SEVERITY_SCORE.get(str(f.get("severity", "")), 0) for f in findings)


def _order_files(files: List[str], ranked_paths: List[str]) -> List[str]:
    ranked_set = {path: idx for idx, path in enumerate(ranked_paths)}
    return sorted(files, key=lambda path: ranked_set.get(path, len(ranked_set)))
